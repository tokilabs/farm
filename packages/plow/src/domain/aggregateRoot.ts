import { ConcreteType, hide, IEnumerable } from '@cashfarm/lang';

import { Identity } from './identity';
import { IEntity, Entity } from './entity';
import { DomainEvent } from './domainEvent';
import { Symbols } from '../symbols';
import { Apply } from './symbolFunctions';
import { EventEnvelope, EventsRegistry } from '../eventSourcing';

export interface IAggregateRoot<TId extends Identity<any>> extends IEntity<TId> {
  readonly id: TId;
  readonly version: number;
  readonly uncommittedChanges: DomainEvent[];
  markChangesAsCommitted(): void;
  loadFromHistory(history: DomainEvent[]): void;
}

const APPLY_CHANGE = Symbol('APPLY_CHANGE');

/**
 * Base implementation of an aggregate root.
 *
 * Extend this class and implement apply{event name}() methods for
 * each event of your aggregate.
 *
 * @export
 * @class AggregateRoot
 * @template TId
 */
export abstract class AggregateRoot<TId extends Identity<any>> extends Entity<TId> implements IAggregateRoot<TId> {
  @hide()
  private _version: number = -1;

  @hide()
  private _changes: DomainEvent[] = [];

  public static load<T extends AggregateRoot<any>>(constructor: ConcreteType<T>, events: IEnumerable<EventEnvelope>): T {
    const t = AggregateRoot.construct(constructor);

    t._version = -1;
    t._changes = [];

    const mappedEvts = events.map(ee => {
      const klass = EventsRegistry.get(ee.eventType);

      return klass[Symbols.EventLoader](ee.eventData);
    });

    t.loadFromHistory(mappedEvts);

    return t;
  }

  /**
   * Simulate a private constructor to allow instantiating orders without
   * required arguments. This should ONLY be used to create Orders when
   * loading from event stream or inside Order.clone() method.
   *
   * @private
   * @static
   * @returns {Order}
   *
   * @memberOf Order
   */
  private static construct<T extends AggregateRoot<any>>(constructor: ConcreteType<T>): T {
    return <T> (<any>constructor)._create();
  }

  private static getDescriptor<T>(realConstructor: ConcreteType<T>): PropertyDescriptorMap {
    const descriptor = {};

    Object.getOwnPropertyNames(realConstructor.prototype).forEach(p => {
      descriptor[p] = Object.getOwnPropertyDescriptor(realConstructor.prototype, p);
    });

    return descriptor;
  }

  get id(): TId {
    return this._id;
  }

  get version(): number{
    return this._version;
  }

  get uncommittedChanges(): DomainEvent[]{
    return this._changes;
  }

  public markChangesAsCommitted() {
    this._version += this._changes.length;
    this._changes.length = 0;
  }

  public loadFromHistory(history: DomainEvent[]) {
    history.forEach( event => this[APPLY_CHANGE](event, false));
  }

  protected applyChange(event: DomainEvent) {
    this[APPLY_CHANGE](event, true);
  }

  private [APPLY_CHANGE](event: DomainEvent, isNew: boolean) {
    const evtName = event[Symbols.EventName] || Object.getPrototypeOf(event).cosntructor.name;

    // Find out the method to apply the function to
    let applyEvent: string | symbol = `apply${evtName}`;

    if (!applyEvent) {
      const constructor = Object.getPrototypeOf(event) ? Object.getPrototypeOf(event).cosntructor : null;

      if (constructor && this[Apply(constructor)] instanceof Function)
        applyEvent = Apply(constructor);
    }

    if (!applyEvent) {
      throw new Error(
        `For each event, an aggregate MUST implement an apply method called either apply${evtName}
        or using a symbol generated by the Apply function, e.g. protected [Apply(MyEvent)](evt: MyEvent): void {}.

        The Aggregate ${this.constructor.name} has no apply method for ${evtName}`);
    }

    this[applyEvent](event);

    if (isNew)
      this._changes.push(event);
  }
}

export default AggregateRoot;
