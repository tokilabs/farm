import { plainToClass, Exclude } from 'class-transformer';

import { ConcreteType, requireByFQN, Guid } from '@cashfarm/lang';

import { Identity } from './identity';
import { IEntity, Entity } from './entity';
import { IDomainEvent } from './domainEvent';
import { Symbols } from '../symbols';
import { Apply } from './symbolFunctions';
import { EventEnvelope, EventsRegistry } from '../eventSourcing';
import { config } from '../config';

const debug = require('debug')('plow:aggregate');

const APPLY_CHANGE = Symbol('APPLY_CHANGE');

export interface IAggregateRoot<TId extends Identity<any> | Guid> extends IEntity<TId> {
  readonly id: TId;
  readonly version: number;
  readonly uncommittedChanges: IDomainEvent[];
  markChangesAsCommitted(): void;
}

/**
 * Base implementation of an aggregate root.
 *
 * Extend this class and implement `[Apply(EvtClass)]()` methods for
 * each event of your aggregate.
 *
 * @export
 * @class AggregateRoot
 * @template TId
 */
export abstract class AggregateRoot<TId extends Identity<any> | Guid> extends Entity<TId> implements IAggregateRoot<TId> {
  @Exclude()
  private _version: number = -1;

  @Exclude()
  private _changes: IDomainEvent[] = [];

  public static load<T extends AggregateRoot<any>>(constructor: ConcreteType<T>, events: EventEnvelope[]): T {
    const t = AggregateRoot.construct(constructor);

    t._version = -1;
    t._changes = [];

    const mappedEvts = events.map(ee => {
      const klass = requireByFQN(ee.eventType);

      const e = plainToClass(klass, ee.event);

      if (e.constructor !== klass) {
        throw new Error(`${klass.name}[EventLoader]() method did not return an instance of ${klass.name}.
          It returned a ${e.constructor ? e.constructor.name : typeof e} instead`);
      }

      return e;
    });

    t.loadFromHistory(mappedEvts);

    return t;
  }

  /**
   * Simulate a private constructor to allow instantiating without
   * required arguments. This should ONLY be used to create Orders when
   * loading from event stream or inside Order.clone() method.
   *
   * @private
   * @static
   * @returns {Order}
   *
   * @memberOf Order
   */
  private static construct<T extends AggregateRoot<any>>(constructor: ConcreteType<T>): T {
    return Object.create(constructor.prototype);
  }

  private static getDescriptor<T>(realConstructor: ConcreteType<T>): PropertyDescriptorMap {
    const descriptor = {};

    Object.getOwnPropertyNames(realConstructor.prototype).forEach(p => {
      descriptor[p] = Object.getOwnPropertyDescriptor(realConstructor.prototype, p);
    });

    return descriptor;
  }

  get id(): TId {
    return this._id;
  }

  get version(): number{
    return this._version;
  }

  get uncommittedChanges(): IDomainEvent[]{
    return this._changes;
  }

  public markChangesAsCommitted() {
    this._version += this._changes.length;
    this._changes.length = 0;
  }

  protected applyChange(event: IDomainEvent) {
    this[APPLY_CHANGE](event, true);
  }

  private loadFromHistory(history: IDomainEvent[]) {
    this._version = history.length - 1;
    history.forEach( event => this[APPLY_CHANGE](event, false));
  }

  private [APPLY_CHANGE](event: IDomainEvent, isNew: boolean) {
    const evtName = event[Symbols.EventName] || event.constructor[Symbols.EventName] || event.constructor.name;

    // Find out the method to apply the function to
    let applyEvent: string | symbol = `apply${evtName}`;

    if (!this[applyEvent]) {
      const constructor = Object.getPrototypeOf(event) ? Object.getPrototypeOf(event).constructor : null;

      if (constructor && this[Apply(constructor)] instanceof Function)
        applyEvent = Apply(constructor);
    }

    if (!applyEvent || !(this[applyEvent] instanceof Function)) {
      if (config.requireApplyForEachEvent) {
        const actualImpl = this[applyEvent] instanceof Function ?
          `The aggregate ${this.constructor.name} property [Apply(${evtName})] is a ${typeof this[applyEvent]}` :
          `The Aggregate ${this.constructor.name} has no apply method for ${evtName}`;

        throw new Error(
          `For each event, an aggregate MUST implement an apply method called either apply${evtName}
          or using a symbol generated by the Apply function, e.g. protected [Apply(${evtName})](evt: ${evtName}): void {}.

          ${actualImpl}`);
      }

      config.defaultApplyFn(this, event);

      return;
    }

    this[applyEvent](event);

    if (isNew)
      this._changes.push(event);
  }
}

export default AggregateRoot;
