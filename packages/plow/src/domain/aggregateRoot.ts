import { ConcreteType, hide, IEnumerable } from '@cashfarm/lang';

import { Identity } from './identity';
import { IEntity, Entity } from './entity';
import { IDomainEvent } from './domainEvent';
import { Symbols } from '../symbols';
import { Apply } from './symbolFunctions';

export interface IAggregateRoot<TId extends Identity<any>> extends IEntity<TId> {
  readonly id: TId;
  readonly version: number;
  readonly uncommittedChanges: IDomainEvent[];
  markChangesAsCommitted(): void;
  loadFromHistory(history: IDomainEvent[]): void;
}

const APPLY_CHANGE = Symbol('APPLY_CHANGE');

/**
 * Base implementation of an aggregate root.
 *
 * Extend this class and implement apply{event name}() methods for
 * each event of your aggregate.
 *
 * @export
 * @class AggregateRoot
 * @template TId
 */
export abstract class AggregateRoot<TId extends Identity<any>> extends Entity<TId> implements IAggregateRoot<TId> {
  @hide()
  protected _version: number;

  @hide()
  private _changes: IDomainEvent[] = [];

  public static load<T extends AggregateRoot<any>>(constructor: ConcreteType<T>, events: IEnumerable<IDomainEvent>): T {
    const t = AggregateRoot.construct(constructor);
    t.loadFromHistory(events);

    return t;
  }

  /**
   * Simulate a private constructor to allow instantiating orders without
   * required arguments. This should ONLY be used to create Orders when
   * loading from event stream or inside Order.clone() method.
   *
   * @private
   * @static
   * @returns {Order}
   *
   * @memberOf Order
   */
  private static construct<T extends AggregateRoot<any>>(constructor: ConcreteType<T>): T {
    return <T> Object.create(constructor.prototype, AggregateRoot.getDescriptor(constructor));
  }

  private static getDescriptor<T>(realConstructor: ConcreteType<T>): PropertyDescriptorMap {
    const descriptor = {};

    Object.getOwnPropertyNames(realConstructor.prototype).forEach(p => {
      descriptor[p] = Object.getOwnPropertyDescriptor(realConstructor.prototype, p);
    });

    return descriptor;
  }

  get id(): TId {
    return this._id;
  }

  get version(): number{
    return this._version;
  }

  get uncommittedChanges(): IDomainEvent[]{
    return this._changes;
  }

  public markChangesAsCommitted() {
    this._changes.length = 0;
  }

  public loadFromHistory(history: IDomainEvent[]) {
    history.forEach( event => this[APPLY_CHANGE](event, false));
  }

  protected applyChange(event: IDomainEvent) {
    this[APPLY_CHANGE](event, true);
  }

  private [APPLY_CHANGE](event: IDomainEvent, isNew: boolean) {
    const evtName = event[Symbols.EventName] || Object.getPrototypeOf(event).cosntructor.name;

    // Find out the method to apply the function to
    let applyEvent = this[`apply${evtName}`];

    if (!applyEvent) {
      const constructor = Object.getPrototypeOf(event) ? Object.getPrototypeOf(event).cosntructor : null;

      if (constructor && this[Apply(constructor)] instanceof Function)
        applyEvent = this[Apply(constructor)](event);
    }

    if (!applyEvent) {
      throw new Error(
        `For each event, an aggregate MUST implement an apply method called either apply${evtName}
        or using a symbol generated by the Apply function, e.g. protected [Apply(MyEvent)](evt: MyEvent): void {}.

        The Aggregate ${this.constructor.name} has no apply method for ${evtName}`);
    }

    applyEvent(event);

    if (isNew)
      this._changes.push(event);
  }
}

export default AggregateRoot;
